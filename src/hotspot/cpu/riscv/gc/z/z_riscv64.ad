//
// Copyright (c) 2019, 2021, Oracle and/or its affiliates. All rights reserved.
// Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//

source_hpp %{

#include "gc/shared/gc_globals.hpp"
#include "gc/z/c2/zBarrierSetC2.hpp"
#include "gc/z/zThreadLocalData.hpp"

%}

source %{
%}

// Load Pointer
instruct zLoadP(iRegPNoSp dst, memory mem)
%{
  match(Set dst (LoadP mem));
  predicate(UseZGC && /* !needs_acquiring_load(n) && */ n->as_Load()->barrier_data() != 0);
  effect(TEMP dst);

  ins_cost(4 * DEFAULT_COST);

  format %{ "ld  $dst, $mem, #@zLoadP" %}

  ins_encode %{
    Unimplemented();
  %}

  ins_pipe(iload_reg_mem);
%}

// Load Pointer Volatile
instruct zLoadPVolatile(iRegPNoSp dst, indirect mem /* sync_memory */, rFlagsReg cr)
%{
  match(Set dst (LoadP mem));
  predicate(UseZGC && /* needs_acquiring_load(n) && */ n->as_Load()->barrier_data() != 0);
  effect(TEMP dst, KILL cr);

  ins_cost(VOLATILE_REF_COST);

  format %{ "ldar  $dst, $mem\t" %}

  ins_encode %{
    Unimplemented();
  %}

  ins_pipe(pipe_serial);
%}

// Store Pointer
instruct zStoreP(memory mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  predicate(UseZGC && /* !needs_releasing_store(n) && */ n->as_Store()->barrier_data() != 0);
  match(Set mem (StoreP mem src));
  effect(TEMP tmp, KILL cr);

  ins_cost(125); // XXX
  format %{ "movq    $mem, $src\t# ptr" %}
  ins_encode %{
    Unimplemented();
  %}
  ins_pipe(pipe_serial);
%}

// Store Pointer Volatile
instruct zStorePVolatile(indirect mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  predicate(UseZGC && /* needs_releasing_store(n) && */ n->as_Store()->barrier_data() != 0);
  match(Set mem (StoreP mem src));
  effect(TEMP tmp, KILL cr);

  ins_cost(125); // XXX
  format %{ "movq    $mem, $src\t# ptr" %}
  ins_encode %{
    Unimplemented();
  %}
  ins_pipe(pipe_serial);
%}

instruct zCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  predicate(UseZGC && /* !needs_acquiring_load_exclusive(n) && */ n->as_LoadStore()->barrier_data() != 0);
  effect(KILL cr, TEMP_DEF res);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval, #@zCompareAndSwapP\n\t"
            "mv $res, $res == $oldval" %}

  ins_encode %{
    Unimplemented();
  %}

  ins_pipe(pipe_slow);
%}

instruct zCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  predicate(UseZGC && /* needs_acquiring_load_exclusive(n) && */ n->as_LoadStore()->barrier_data() != 0);
  effect(KILL cr, TEMP_DEF res);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $mem, $oldval, $newval, #@zCompareAndSwapPAcq\n\t"
            "mv $res, $res == $oldval" %}

  ins_encode %{
    Unimplemented();
  %}

  ins_pipe(pipe_slow);
%}

instruct zCompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval) %{
  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  predicate(UseZGC && /* !needs_acquiring_load_exclusive(n) && */ n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP_DEF res);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $res = $mem, $oldval, $newval, #@zCompareAndExchangeP" %}

  ins_encode %{
    Unimplemented();
  %}

  ins_pipe(pipe_slow);
%}

instruct zCompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval) %{
  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  predicate(UseZGC && /* needs_acquiring_load_exclusive(n) && */ n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP_DEF res);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "cmpxchg $res = $mem, $oldval, $newval, #@zCompareAndExchangePAcq" %}

  ins_encode %{
    Unimplemented();
  %}

  ins_pipe(pipe_slow);
%}

instruct zGetAndSetP(indirect mem, iRegP newv, iRegPNoSp prev, rFlagsReg cr) %{
  match(Set prev (GetAndSetP mem newv));
  predicate(UseZGC && /* !needs_acquiring_load_exclusive(n) && */ n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP_DEF prev, KILL cr);

  ins_cost(2 * VOLATILE_REF_COST);

  format %{ "atomic_xchg  $prev, $newv, [$mem], #@zGetAndSetP" %}

  ins_encode %{
    Unimplemented();
  %}

  ins_pipe(pipe_serial);
%}

instruct zGetAndSetPAcq(indirect mem, iRegP newv, iRegPNoSp prev, rFlagsReg cr) %{
  match(Set prev (GetAndSetP mem newv));
  predicate(UseZGC && /* needs_acquiring_load_exclusive(n) && */ n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP_DEF prev, KILL cr);

  ins_cost(VOLATILE_REF_COST);

  format %{ "atomic_xchg_acq  $prev, $newv, [$mem], #@zGetAndSetPAcq" %}

  ins_encode %{
    Unimplemented();
  %}
  ins_pipe(pipe_serial);
%}
